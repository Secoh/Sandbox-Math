// primes-32-encoder.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

// This file is candidate for Sklib
// LGPL 2.0 for now.

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include <vector>

#include <sklib/include/timer.hpp>
#include <sklib/include/cmdpar.hpp>
#include <sklib/include/checksum.hpp>
#include <sklib/include/bitwise.hpp>
#include <sklib/include/math.hpp>

SKLIB_DECLARE_CMD_PARAMS(options_t)
{
    SKLIB_OPTION_STRING(csv);  // csv clear text file, created by generator
    SKLIB_OPTION_STRING(pack); // packed file of primes
    SKLIB_OPTION_SWITCH(e);    // encode indexes
    SKLIB_OPTION_SWITCH(d);    // decode from packed to unpacked, autodetect file format
    SKLIB_OPTION_SWITCH(t);    // test packed file, similar to "d" option, but without writing
    SKLIB_OPTION_SWITCH(o);    // overwrite destination file if it exists
}
Options;

bool test_file_exists(const char *name)
{
    std::ifstream TestOutput(name);
    return TestOutput.is_open();
}

// --------------------------------------------------------------------------------------
// 
// encodes increment between prime indexes, 0 = inrement by 1, 1 - by 2, etc
// primes 2, 3, and 5 are assumed but not stored in the coding
// 1-st element to write is increment from 5 to 7:
// index(5)=0, index(7)=1, delta=1, therefore, written: 0000

int main(int argn, char *argc[])
{
    using namespace sklib::primes_compressor;

    bool parsed = Options(argn, argc);
    bool encode = Options.e && !Options.d && !Options.t && Options.csv.is_present() && Options.pack.is_present();
    bool decode = Options.d && !Options.e && !Options.t && Options.csv.is_present() && Options.pack.is_present();
    bool tstpak = Options.t && !Options.e && !Options.d && Options.pack.is_present();

    if (!parsed || !(encode || decode || tstpak))
    {
        std::cout << "Encode or decode the primes list generated by primes-32-generator.\n"
                     "Usage: primes-32-encoder.exe -e -csv source_text_file -pack destination [-o]\n"
                     "       primes-32-encoder.exe -d -pack source_packed_file -csv destination [-o]\n"
                     "       primes-32-encoder.exe -t -pack source_packed_file\n"
                     "Use option -o to overwrite if the destination file exists\n";
        return 1;
    }

    sklib::timer_stopwatch_type strobe(1000);
    sklib::crc_32_iso Checksum;

    uint32_t nrecords = 0;

    if (encode)
    {
        std::ifstream Input(Options.csv);
        if (!Input.is_open())
        {
            std::cout << "Cannot read file " << Options.csv << "\n";
            return -1;
        }

        if (test_file_exists(Options.pack) && !Options.o)
        {
            std::cout << "File " << Options.pack << " exists. Use -o to overwrite\n";
            return -1;
        }

        sklib::bits_file_type Packed(Options.pack);
        if (!Packed.file_stream().is_open())
        {
            std::cout << "Cannot write file " << Options.pack << "\n";
            return -1;
        }

        static constexpr uint32_t P_start = sklib::prime_candidate<uint32_t>(0);
        uint32_t Idx = 0;
        uint32_t P = 0;
        while (true)
        {
            std::string str, sord, sdata;
            if (!std::getline(Input, str))
            {
                std::cout << "File error: Premature ending\n";
                return -1;
            }

            auto Idx_prev = Idx;
            auto P_prev = P;

            std::stringstream istr{ str };
            std::getline(istr, sdata, ',');
            P = sklib::stoi<uint32_t>(sdata.c_str());

            if (!P && P_prev)
            {
                // 0 in the beginning of a row is to indicate EOF
                if (!std::getline(Input, str))
                {
                    std::cout << "File error - invalid ending\n";
                    return 1;
                }

                Packed.write(ones_cap);
                Packed.write(sklib::bits_pack<sklib::bits_width_v<uint32_t>>(Checksum.get()));
                Packed.write_flush();

                if (sklib::stoi<uint32_t>(str.c_str()) != Checksum.get())
                {
                    std::cout << "Warning: input/control CRC mismatch\n";
                }

                std::cout << nrecords << "\nDone!\n";
                return 0;
            }

            Checksum.update_integer_lsb(P);

            nrecords++;
            if (strobe(true)) std::cout << nrecords << "\r" << std::flush;

            std::getline(istr, sord, ',');
            Idx = sklib::stoi<int>(sord.c_str());

            // parsing starts at P=7 and P_prev=5, here we have the fist valid index delta
            bool lead_in = (P <= P_start);

            if (P <= P_prev || (lead_in ? Idx : (Idx <= Idx_prev)))
            {
                std::cout << "File error: Incorrect content. Primes and indexes must be accending\n";
                return -1;
            }

            if (lead_in) continue;

            if (P != sklib::prime_candidate<uint32_t>(Idx) || sklib::prime_candidate_to_index(P) != Idx)
            {
                std::cout << "File error: Prime number and its index mismatch.\n"
                          << "P=" << P << ", Idx=" << Idx << "\n";
                return -1;
            }

            auto code = Idx - Idx_prev - 1;  // non-negative by definition

            if (code < tierA)
            {
                Packed.write(sklib::bits_pack<zone0>(code));
            }
            else if (code < tierB)
            {
                Packed.write(onesA);
                Packed.write(sklib::bits_pack<zoneA>(code-tierA));
            }
            else if (code < tierC)
            {
                Packed.write(onesB);
                Packed.write(sklib::bits_pack<zoneB>(code-tierB));
            }
            else if (code < tier_cap)
            {
                Packed.write(onesC);
                Packed.write(sklib::bits_pack<zoneC>(code - tierC));
            }
            else
            {
                std::cout << "Unexpected error: Large Prime Gap encountered, unable to continue.\n"
                          << "P=" << P << ", Idx=" << Idx << ", d=" << code << "\n";
                return -1;
            }
        }

        std::cout << nrecords << "\nDone!\n";
    }
    else if (decode || tstpak)
    {
        sklib::bits_file_type Packed(Options.pack, std::ios_base::in);
        if (!Packed.file_stream().is_open())
        {
            std::cout << "Cannot read file " << Options.pack << "\n";
            return -1;
        }

        std::ofstream Output;
        if (decode)
        {
            if (test_file_exists(Options.csv) && !Options.o)
            {
                std::cout << "File " << Options.csv << " exists. Use -o to overwrite\n";
                return -1;
            }

            Output.open(Options.csv);
            if (!Output.is_open())
            {
                std::cout << "Cannot write file " << Options.csv << "\n";
                return -1;
            }
        }

        auto printlog = [](void*, uint32_t nrec) { std::cout << nrec << "\r" << std::flush; };

        std::vector<uint32_t> Primes;
        uint32_t CRC;
        auto R = sklib::primes_decode(Packed, Primes, CRC, printlog);

        if (!sklib::is_primes_decoder_status_good(R))
        {
            std::cout << sklib::primes_decoder_status_msg(R);
        }
        else if (decode)
        {
            std::cout << "\nWriting text file...\r" << std::flush;

            for (auto P : Primes) Output << P << "," << (P<5 ? 0 : sklib::prime_candidate_to_index(P)) << "\n";
            Output << 0 << "\n" << CRC << "\n";
        }

        std::cout << "\nDone!\n";
    }

    return 0;
}

